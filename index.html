<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>darion.johannes.yaphet</title>
  <meta name="author" content="Darion Yaphet">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="darion.johannes.yaphet"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="darion.johannes.yaphet" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">darion.johannes.yaphet</a></h1>
  <h2><a href="/">long is the way and hard  that out of Hell leads up to light</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-21T16:00:00.000Z"><a href="/2016/11/22/live/math/">2016-11-22</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/22/live/math/">Mathematics</a></h1>
  

    </header>
    <div class="entry">
      
        <p>数学三大危机：</p>
<ol>
<li>希帕索斯（Hippasu，米太旁登地方人，公元前5世纪）发现了一个腰为1的等腰直角三角形的斜边（即根号2）永远无法用最简整数比（不可公度比）来表示，从而发现了第一个无理数，推翻了毕达哥拉斯的著名理论。相传当时毕达哥拉斯派的人正在海上，但就因为这一发现而把希帕索斯抛入大海；</li>
<li>微积分的合理性遭到严重质疑，险些要把整个微积分理论推翻；</li>
<li>罗素悖论：S由一切不是自身元素的集合所组成，那S包含S吗？用通俗一点的话来说，小明有一天说：“我正在撒谎！”问小明到底撒谎还是说实话。罗素悖论的可怕在于，它不像最大序数悖论或最大基数悖论那样涉及集合高深知识，它很简单，却可以轻松摧毁集合理论！</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-17T16:00:00.000Z"><a href="/2016/11/18/algorithms/RedBlackTree/">2016-11-18</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/18/algorithms/RedBlackTree/">RedBlackTree</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red Black Tree"></a>Red Black Tree</h3><p>Red Black Tree由Rudolf Bayer发明的，当时被称为平衡二叉B树。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p>
<p>红黑树每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了额外要求:</p>
<ol>
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>每个叶节点是黑色的</li>
<li>每个红色节点的两个子节点都是黑色</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li>
</ol>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长`。</p>
<p><img src="resource/Red-black_tree_example.svg" alt="RedBlackTree"></p>
<p>Reference :</p>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/红黑树" target="_blank" rel="external">Wiki 红黑树</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91" target="_blank" rel="external">Wiki 平衡树</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-13T02:08:48.000Z"><a href="/2016/11/13/distribution/beam/">2016-11-13</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/13/distribution/beam/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Beam"><a href="#Beam" class="headerlink" title="Beam"></a>Beam</h3><p>Apache Beam的主要目标是统一批处理和流处理的编程范式，为无限，乱序，web-scale的数据集处理提供简单灵活，功能丰富以及表达能力十分强大的SDK。</p>
<p>Apache Beam项目重点在于数据处理的编程范式和接口定义，并不涉及具体执行引擎的实现，Apache Beam希望基于Beam开发的数据处理程序可以执行在任意的分布式计算引擎上。</p>
<p><strong>Apache Beam基本架构</strong></p>
<ol>
<li>统一批处理和流处理的需求。</li>
<li>生成的分布式数据处理任务应该能够在各个分布式执行引擎上执行，用户可以自由切换分布式数据处理任务的执行引擎与执行环境。</li>
</ol>
<p>Apache Beam主要由<code>Beam SDK</code>和<code>Beam Runner</code>组成，<code>Beam SDK</code>定义了开发分布式数据处理任务业务逻辑的API接口，生成的的分布式数据处理任务Pipeline交给具体的<code>Beam Runner</code>执行引擎。</p>
<p><strong>Beam Model</strong></p>
<ol>
<li>数据。分布式数据处理要处理的数据类型一般可以分为两类，有限的数据集和无限的数据流。</li>
<li>时间。Process Time是指数据进入分布式处理框架的时间，而Event-Time则是指数据产生的时间。</li>
<li>乱序。对于流处理框架处理的数据流来说，其数据的到达顺序可能并不严格按照Event-Time的时间顺序。对于基于Event Time定义的时间窗口来说，可能存在时间靠前的消息在时间靠后的消息后到达的情况。</li>
</ol>
<p>Beam Model处理的目标数据是无限的时间乱序数据流，不考虑时间顺序或是有限的数据集可看做是无限乱序数据流的一个特例。</p>
<p>Beam Model从下面四个维度归纳了用户在进行数据处理的时候需要考虑的问题：</p>
<ol>
<li>What。如何对数据进行计算？</li>
<li>Where。数据在什么范围中计算？</li>
<li>When。何时将计算结果输出？</li>
<li>How。迟到数据如何处理？</li>
</ol>
<p><strong>Beam SDK</strong></p>
<p><code>Pipeline</code> : </p>
<p><code>PCollection</code> : </p>
<p><code>Transform</code> :</p>
<p><code>Source</code> and <code>Sink</code> : </p>
<p>A typical Beam driver program works as follows:</p>
<ol>
<li>Create a <code>Pipeline</code> object and set the pipeline execution options, including the Pipeline Runner.</li>
<li>Create an initial <code>PCollection</code> for pipeline data, either using the Source API to read data from an external source, or using a Create transform to build a PCollection from in-memory data.</li>
<li>Apply <code>Transforms</code> to each <code>PCollection</code>. Transforms can change, filter, group, analyze, or otherwise process the elements in a PCollection. A transform creates a new output PCollection without consuming the input collection. A typical pipeline applies subsequent transforms to the each new output PCollection in turn until processing is complete.</li>
<li>Output the final, transformed PCollection(s), typically using the Sink API to write data to an external source.</li>
<li>Run the pipeline using the designated Pipeline Runner.</li>
</ol>
<p><em>Creating the Pipeline</em></p>
<p><em>Working with PCollections</em></p>
<p>Reference :</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/23618169" target="_blank" rel="external">Apache Beam: 下一代的大数据处理标准</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-08T02:52:38.000Z"><a href="/2016/11/08/network/jetty/">2016-11-08</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/08/network/jetty/"></a></h1>
  

    </header>
    <div class="entry">
      
        <pre><code>###Jetty
</code></pre><p><code>Configure</code></p>
<p><strong>Configuring the Server</strong></p>
<table>
<thead>
<tr>
<th>Desc</th>
<th>Value </th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadPool</td>
<td></td>
</tr>
<tr>
<td>Handlers</td>
<td></td>
</tr>
<tr>
<td>Server Attributes</td>
<td></td>
</tr>
<tr>
<td>Server fields</td>
<td></td>
</tr>
<tr>
<td>Connectors</td>
<td></td>
</tr>
<tr>
<td>Services</td>
<td></td>
</tr>
</tbody>
</table>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-08T02:52:38.000Z"><a href="/2016/11/08/network/libuv/">2016-11-08</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/08/network/libuv/"></a></h1>
  

    </header>
    <div class="entry">
      
        <p>###Libuv</p>
<p>libuv是一个高性能事件驱动的程序库,采用了异步, 事件驱动编程风格,提供了一套事件循环和基于IO通知回调函数。</p>
<p>Libuv Hello World示例程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;uv.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    uv_loop_t *loop = uv_loop_new();</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now quitting.\n&quot;);</span><br><span class="line">    uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-08T02:52:38.000Z"><a href="/2016/11/08/network/finagle/">2016-11-08</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/08/network/finagle/"></a></h1>
  

    </header>
    <div class="entry">
      
        <p>###Finagle</p>
<p><a href="http://monkey.org/~marius/funsrv.pdf" target="_blank" rel="external">http://monkey.org/~marius/funsrv.pdf</a></p>
<ol>
<li><p><code>Futures</code> The results of asynchronous operations are represented by futures which compose to express dependencies between operations.</p>
</li>
<li><p><code>Services</code> Systems boundaries are represented by asynchronous functions called services. They provide a symmetric and uniform API: the same abstraction represents both clients and servers.</p>
</li>
<li><p><code>Filters</code> Application-agnostic concerns  are encapsulated by filters which compose to build services from multiple independent modules.</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-08T02:52:38.000Z"><a href="/2016/11/08/network/netty/">2016-11-08</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/08/network/netty/"></a></h1>
  

    </header>
    <div class="entry">
      
        <p>##Netty</p>
<p><img src="../resource/netty/lable.png" alt="Netty"></p>
<p>###架构总览<br><img src="../resource/netty/architecture.png" alt="archietecture"></p>
<p>Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server. – Netty 官网</p>
<p>总体来说 Netty算是一个异步-事件驱动网络框架，具有很高的性能与扩展能力。</p>
<p>###重要组件介绍</p>
<ol>
<li><p>ServerBootstrap instance is then configured, as shown in the following listing, to set options, such as the port, the threading model/event loop, and the server handler to handle the business logic </p>
</li>
<li><p>EventExecutor : a special EventExecutorGroup which comes with some handy methods to see if a Thread is executed in a event loop.</p>
</li>
<li><p>EventExecutorGroup : responsible for providing the EventExecutor’s to use via its next() method. </p>
</li>
</ol>
<p>2.Bootstrap</p>
<p>3.Channel</p>
<p>4.ChannelPipeline</p>
<p>可以理解为ChannelHandler的有序容器</p>
<p>5.ChannelBuffer</p>
<p>6.ChannelHandler</p>
<p>ChannelHandler分为ChannelInboundHandler与ChannelOutboundHandler两类</p>
<p>ChannelInboundHandler对从Client –&gt; Server的消息进行处理</p>
<p>ChannelOutboundHandler对从Server –&gt; CLient的消息进行处理</p>
<p>7.ChannelHandlerContext</p>
<p>###示例程序<br>以著名的Discard程序为例  说明Netty程序基本结构</p>
<p>首先是Server端结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .handler(new LoggingHandler(LogLevel.INFO))</span><br><span class="line">    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">            ChannelPipeline p = ch.pipeline();</span><br><span class="line">            if (sslCtx != null) &#123;</span><br><span class="line">                p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">            &#125;</span><br><span class="line">            p.addLast(new DiscardServerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Bind and start to accept incoming connections.</span><br><span class="line">ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">// Wait until the server socket is closed.</span><br><span class="line">// In this example, this does not happen, but you can do that to gracefully</span><br><span class="line">// shut down your server.</span><br><span class="line">f.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>
<p>之后是Client端结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line">Bootstrap b = new Bootstrap();</span><br><span class="line">b.group(group)</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">            ChannelPipeline p = ch.pipeline();</span><br><span class="line">            if (sslCtx != null) &#123;</span><br><span class="line">                p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));</span><br><span class="line">            &#125;</span><br><span class="line">            p.addLast(new DiscardClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>AbstractBootstrap中<br>doBind(final SocketAddress localAddress)</p>
<p>init(Channel channel)</p>
<p>A Future is an abstraction, which represents a value that may become available at some point. </p>
<p>A Future object either holds the result of a computation or, in the case of a failed computation, an exception. </p>
<p>##Your first Netty application </p>
<p>A Netty application begins with one of the Bootstrap classes, a Bootstrap is a construct Netty provides that makes it easy for you to configure how Netty should setup or bootstrap the application.</p>
<p>In order to allow multiple protocols and various ways of processing data, Netty has what are called handlers.</p>
<p>The ChannelInboundHandler receives messages which you can process and decide what to do with it.</p>
<p>When a channel is registered, Netty binds that channel to a single EventLoop  for the lifetime of that Channel. EventLoop is always bound to a single Thread that never changed during its life time. </p>
<p>EventLoopGroup contains one or more EventLoop</p>
<p>Netty allows the same EventLoopGroup to be used for processing IO and accepting<br>connections. </p>
<p>To understand what happens to data when it is written or read, it is first essential to have some understanding of what handlers are. </p>
<p>Handlers themselves depend upon the aforementioned ChannelPipeline to prescribe their order of execution. </p>
<p>A ChannelHandler may do some action on the data and then may pass it to the next<br>ChannelHandler in the ChannelPipeline. Another often action is do not do any action at all and just pass the specific event to the next ChannelHandler in the ChannelPipeline. This next ChannelHandler may handle it then or just forward it to the next ChannelHandler again. </p>
<p>Both ChannelInboundHandler and ChannelOutboundHandler can be mixed into the same ChannelPipeline. </p>
<p>###Encoding</p>
<p>When you send or receive a message with Netty it must be converted from one form to another. </p>
<p>If the message is being received it must be converted from bytes to a Java object (decoded by some kind of decoder). </p>
<p>If the message is being sent it must be converted from a<br>Java object to bytes (encoded by some type of encoder). </p>
<p>##Transports</p>
<p><code>Channel interface</code>, which is used for all of the outbound operations. All I/O operations in Netty are asynchronous. </p>
<pre><code>A channel provides a user:
Current state of the channel 
ChannelConfig configuration parameters of the channel
I/O operations that the channel supports
ChannelPipeline which handles all I/O events and requests
</code></pre><p>The ChannelPipeline holds all of the ChannelHandler instances that should be used for the inbound and outbound data that is passed through the channel. </p>
<p>ChannelHandler use for :</p>
<ol>
<li>Transforming data from one format to another.  </li>
<li>Notifying you of exceptions. </li>
<li>Notifying you when a Channel becomes active or inactive.</li>
<li>Notifying you once a channel is registered/deregistered from an EventLoop.</li>
<li>Notifying you about user-specific events. </li>
</ol>
<p>###IOI(Old blocking I/O )</p>
<p>The OIO transport is a compromise in Netty.</p>
<p>##Buffers</p>
<p><strong>Different types of ByteBuf</strong></p>
<ol>
<li>HEAP BUFFERS</li>
<li>DIRECT BUFFERS</li>
<li>COMPOSITE BUFFERS</li>
</ol>
<p>##Transports<br>The heart of the transport API is the <strong>Channel</strong> interface, which is used for all of the outbound operations. A channel has a <em>ChannelPipeline</em> and a <em>ChannelConfig</em><br>assigned to it.</p>
<p>The <strong>ChannelPipeline</strong> holds all of the ChannelHandler instances that should be used for the inbound and outbound data that is passed through the channel. </p>
<p>##ChannelHandler</p>
<p>your channel handler must extend the ChannelInboundHandlerAdapter class and override the messageReceived method. This method is called every time messages are received, which in this case are bytes. </p>
<p>channelActive Called after the connection to the server is established</p>
<p>channelRead0  Called after you receive data from the server </p>
<p>exceptionCaught  Called if any exception was raised during processing </p>
<p><strong>ChannelInboundHandler</strong> and <strong>ChannelOutboundHandler</strong> extends <strong>ChannelHandler</strong></p>
<p>##ChannelPipeline</p>
<p>The <strong>ChannelPipeline</strong> holds all of the ChannelHandler instances that should be used for the <em>inbound</em> and <em>outbound</em> data that is passed through the channel. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">                                              I/O Request</span><br><span class="line">                                          via &#123;@link Channel&#125; or</span><br><span class="line">                                      &#123;@link ChannelHandlerContext&#125;</span><br><span class="line">                                                    |</span><br><span class="line">+---------------------------------------------------+---------------+</span><br><span class="line">|                           ChannelPipeline         |               |</span><br><span class="line">|                                                  \|/              |</span><br><span class="line">|    +---------------------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">|               |                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  .               |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">|        [ method call]                       [method call]         |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">|               .                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">|               |                                  \|/              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              /|\                                  |               |</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">                |                                  \|/</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">|               |                                   |               |</span><br><span class="line">|       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">|                                                                   |</span><br><span class="line">|  Netty Internal I/O Threads (Transport Implementation)            |</span><br><span class="line">+-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p><code>Included transports</code></p>
<p><strong>NIO  Nonblocking I/O</strong> </p>
<p><strong>OIO  Old blocking I/O</strong></p>
<p><strong>Local  In VM transport</strong></p>
<p><strong>Embedded transport</strong></p>
<p>##Codec</p>
<p>##Bootstrap</p>
<p>A Netty application begins with one of the Bootstrap classes, is a construct Netty provides that makes it easy for you to configure how Netty should setup or bootstrap the application.</p>
<p>The <strong>ChannelInboundHandler</strong> receives messages which you can process and decide what to do with it. You may also write/flush data out from inside an ChannelInboundHandler when your application needs to provide a response.</p>
<p><strong>ChannelInitializer</strong> is to add <strong>ChannelHandler</strong> implementations to whats called the <strong>ChannelPipeline</strong>. </p>
<p>All Netty applications are based on what is called a <strong>ChannelPipeline</strong>. </p>
<p>All IO operations in Netty are performed asynchronously.</p>
<p><strong>ChannelFuture</strong> is a special java.util.concurrent.Future, which allos you to register ChannnelFutureListeners tot he ChannelFuture.</p>
<p>##Thread Model </p>
<p><code>ChannelHandlers</code> contain your business logic, are guaranteed to be executed by <code>a single thread</code> at the same time for a specific Channel. This doesnt mean Netty fails to use multithreading, but it does limit each connection<br>to one thread as this design works well for nonblocking execution. </p>
<p>Theres no need for you to think about any of the issues you often have when working with multithreaded applications. </p>
<hr>
<p><code>General API for compression codecs</code></p>
<p>Each compression codec is presented as its own class. It’s difficult to switch one compression codec to another without significant code modifications.</p>
<p>Modifications:<br>Added classes:</p>
<ul>
<li><code>CompressionCodecFactory</code> - factory for all compression codecs</li>
<li><code>CompressionDecoder</code> - abstract class, parent for all compression decoders</li>
<li><code>CompressionEncoder</code> - abstract class, parent for all compression encoders</li>
<li><code>CompressionFormat</code> - enum with all available compression formats</li>
</ul>
<p>Extend all compression encoders and decoders to use new abstract classes.</p>
<p>Result:General API for every compression codecs.</p>
<hr>
<p>Reference :</p>
<ol>
<li><a href="http://netty.io/wiki/new-and-noteworthy-in-4.0.html" target="_blank" rel="external">New and noteworthy in 4.0</a></li>
<li><a href="http://blog.csdn.net/SpiderDog/article/category/1800249" target="_blank" rel="external">Netty4学习笔记</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-07T03:24:34.000Z"><a href="/2016/11/07/machine_learning/BoltzmannMachine/">2016-11-07</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/07/machine_learning/BoltzmannMachine/"></a></h1>
  

    </header>
    <div class="entry">
      
        
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-05T16:00:00.000Z"><a href="/2016/11/06/network/tcp/">2016-11-06</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/06/network/tcp/">TCP</a></h1>
  

    </header>
    <div class="entry">
      
        <p><strong>TCP拥塞控制机制</strong></p>
<p><code>拥塞的发生与其不可避免</code></p>
<p>拥塞发生的主要原因在于网络能够提供的资源不足以满足用户的需求，这些资源包括缓存空间、链路带宽容量和中间节点的处理能力。由于互联网的设计机制导致其缺乏“接纳控制”能力，因此在网络资源不足时不能限制用户数量，而只能靠降低服务质量来继续为用户服务，也就是“尽力而为”的服务。<br>但是，是不是说只要增加网络资源，就能避免拥塞呢？答案却是否定的！拥塞虽然是由于网络资源的稀缺引起的，但单纯增加资源并不能避免拥塞的发生。例如增加缓存空间到一定程度时，只会加重拥塞，而不是减轻拥塞，这是因为当数据包经过长时间排队完成转发时，它们很可能早已超时，从而引起源端超时重发，而这些数据包还会继续传输到下一路由器，从而浪费网络资源，加重网络拥塞。事实上，缓存空间不足导致的丢包更多的是拥塞的“症状”而非原因。另外，增加链路带宽及提高处理能力也不能解决拥塞问题。<br>例如：我们有四台主机ABCD连接路由器R，所有链路带宽都是1Gbps，如果A和B同时向C以1Gbps的速率发送数据，则路由器R的输入速率为2Gbps，而输出速率只能为1Gbps，从而产生拥塞。避免拥塞的方法只能是控制AB的速率，例如，都是0.5Gbps，但是，这只是一种情况，倘若D也向R发送数据，且速率为1Gbps，那么，我们先前的修正又是不成立的，可见，拥塞其实是一个动态问题，我们没有办法用一个静态方案去解决，从这个意义上来说，拥塞是不可避免的。</p>
<p><code>流量控制</code></p>
<p>早期的TCP协议只有基于窗口的流控制（flow control）机制，我们简单介绍一下，并分析其不足。<br>在TCP中，为了实现可靠性，发送方发出一个数据段之后要等待接受方相应的确认信息，而不是直接发送下一个分组。具体的技术是采用滑动窗口，以便通信双方能够充分利用带宽。滑动窗口允许发送方在收到接收方的确认之前发送多个数据段。窗口大小决定了在收到目的地确认之前，一次可以传送的数据段的最大数目。窗口大小越大，主机一次可以传输的数据段就越多。当主机传输窗口大小数目的数据段后，就必须等收到确认，才可以再传下面的数据段。例如，若视窗的大小为 1，则传完数据段后，都必须经过确认，才可以再传下一个数据段；当窗口大小等于3时，发送方可以一次传输3个数据段，等待对方确认后，再传输下面三个数据段。</p>
<p>窗口的大小在通信双方连接期间是可变的，通信双方可以通过协商动态地修改窗口大小。在TCP的每个确认中，除了指出希望收到的下一个数据段的序列号之外，还包括一个窗口通告，通告中指出了接收方还能再收多少数据段（我们可以把通告看成接收缓冲区大小）。如果通告值增大，窗口大小也相应增大；通告值减小，窗口大小也相应减小。但是我们可以发现，接收端并没有特别合适的方法来判断当前网络是否拥塞，因为它只是被动得接收，不像发送端，当发出一个数据段后，会等待对方得确认信息，如果超时，就可以认为网络已经拥塞了。所以，改变窗口大小的唯一根据，就是接收端缓冲区的大小了。</p>
<p>流量控制作为接受方管理发送方发送数据的方式，用来防止接受方可用的数据缓存空间的溢出。流控制是一种局部控制机制，其参与者仅仅是发送方和接收方，它只考虑了接收端的接收能力，而没有考虑到网络的传输能力；而拥塞控制则注重于整体，其考虑的是整个网络的传输能力，是一种全局控制机制。正因为流控制的这种局限性，从而导致了拥塞崩溃现象的发生。</p>
<p><code>重传</code> </p>
<p>1、一旦收到确认，发送方关闭重发定时器并且将数据片的备份从重发队列中删除。发送方如果在规定的时间内没有收到数据确认，就重传该数据。<br>2、当TCP超时并重传时，它不一定要重传同样的报文段，相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能(当然，这个较大的报文段不能够超过接收方声明的MSS)。在协议中这是允许的，因为TCP是使用字节序号而不是报文段序号来进行识别它所要发送的数据和进行确认。<br>3、重发定时器<br>(1)  每一次一个包含数据的包被发送（包括重发），如果该定时器没有运行则启动它，使得它在RTO秒之后超时（按照当前的RTO值）。<br>(2)  当所有的发出数据都被确认之后，关闭该重发定时器。<br>(3)  当接收到一个ACK确认一个新的数据，重新启动该重发定时器，使得它在RTO秒之后超时（按照当前的RTO值）</p>
<p><code>TCP拥塞控制机制</code></p>
<p>TCP的拥塞控制由4个核心算法组成：“慢启动”（Slow Start）、“拥塞避免”（Congestion voidance）、“快速重传 ”（Fast Retransmit）、“快速恢复”（Fast Recovery）。具体的流程图可以参见：<a href="http://www.eventhelix.com/RealtimeMantra/Networking/。发送端叫做client，接收端叫做server，每个segment长度为512字节，阻塞窗口长度为cwnd（简化起见，下面以segment为单位），sequence" target="_blank" rel="external">http://www.eventhelix.com/RealtimeMantra/Networking/。发送端叫做client，接收端叫做server，每个segment长度为512字节，阻塞窗口长度为cwnd（简化起见，下面以segment为单位），sequence</a> number为seq_num，acknowledges number为ack_num。通常情况下，TCP每接收到两个segment，发送一个ack。</p>
<p>－－ 慢启动<br>  早期开发的TCP应用在启动一个连接时会向网络中发送大量的数据包，这样很容易导致路由器缓存空间耗尽，网络发生拥塞，使得TCP连接的吞吐量急剧下降。由于TCP源端一开始并不知道网络资源当前的利用状况，因此新建立的TCP连接不能一开始就发送大量数据，而只能逐步增加每次发送的数据量，以避免上述现象的发生，这里有一个“学习”的过程。<br>假设client要发送5120字节到server，慢启动过程如下：<br>1.初始状态，cwnd=1,seq_num=1；client发送第一个segment;<br>2.server接收到512字节（一个segment），回应ack_num=513;<br>3.client接收ack(513)，cwnd＝1+1=2;现在可以一次发送2个数据段而不必等待ack<br>4.server接收到2个segment，回应ack_num=513+512*2=1537<br>5.client接收ack(1537)，cwnd=2+1;一次发送3个数据段<br>6.server接收到3个segment，回应2个ack，分别为ack_num=1537+1024=2561和ack_num=2561+512=3073<br>7.client接收ack(2561)和ack(3073),cwnd=3+2=5；一次可以发送5个数据段，但是只用4个就满足要求了<br>8.server接收到4个segment，回应2个ack，分别为4097,5121<br>9.已经发送5120字节，任务完成！</p>
<p>总结一下：<br>当建立新的TCP连接时，拥塞窗口（congestion window，cwnd）初始化为一个数据包大小。源端按cwnd大小发送数据，每收到一个ACK确认，cwnd就增加一个数据包发送量。</p>
<p>－－ 拥塞避免<br>  可以想象，如果按上述慢启动的逻辑继续下去而不加任何控制的话，必然会发生拥塞，引入一个慢启动阈值ssthresh的概念，当cwnd&lt;ssthresh的时候，tcp处于慢启动状态，否则，进入拥塞避免阶段。通常，ssthresh初始化为<br>64 Kbytes。<br>  当cwnd = 64947 + 512 = 65459，进入拥塞避免阶段，假设此时seq_num = _101024：<br>  1.client一次发送cwnd，但是先考虑头两个segment<br>  2.server回应ack_num = 102048<br>  3.client接收到ack(102048),cwnd = 65459 + [(512 * 512) /65459] = 65459 + 4 = 65463，也就是说，每接到一个ack，cwnd只增加4个字节。<br>  4.client发送一个segment，并开启ack timer,等待server对这个segment的ack，如果超时，则认为网络已经处于拥塞状态，则重设慢启动阀值ssthresh=当前cwnd/2＝65463/2=32731，并且，立刻把cwnd设为1，很极端的处理！<br>  5.此时，cwnd&lt;ssthresh，所以，恢复到慢启动状态。</p>
<p>总结一下：<br>如果当前cwnd达到慢启动阀值，则试探性的发送一个segment，如果server超时未响应，TCP认为网络能力下降，必须降低慢启动阀值，同时，为了避免形势恶化，干脆采取极端措施，把发送窗口降为1，个人感觉应该有更好的方法。</p>
<p>－－ 快速重传和快速恢复<br>  前面讲过标准的重传，client会等待RTO时间再重传，但有时候，不必等这么久也可以判断需要重传，例如：client一次发送8个segment，seq_num起始值为100000，但是由于网络原因，100512丢失，其他的正常，则server会响应4个ack(100512)(为什么呢，tcp会把接收到的其他segment缓存起来，ack_num必须是连续的)，这时候，client接收到四个重复的ack，它完全有理由判断100512丢失，进而重传，而不必傻等RTO时间了。这就是快速重传。<br>  那么，什么是快速恢复呢？我们通常认为client接收到3个重复的ack后，就会开始快速重传，但是，如果还有更多的重复ack呢，如何处理？这就是快速恢复要做的，事实上，我们可以把快速恢复看作是快速重传的后续处理，它不是一种单独存在的形态。</p>
<p>以下是具体的流程：<br>假设此时cwnd=70000,client发送4096字节到server,也就是8个segment，起始seq_num = _100000：</p>
<ol>
<li>client发送seq_num = _100000</li>
<li>seq_num =100512的segment丢失</li>
<li>client发送seq_num = _101024</li>
<li>server接收到两个segment，它意识到100512丢失，先把收到的这两个segment缓存起来</li>
<li>server回应一个ack(100512),表示它还期待这个segment</li>
<li>client发送seq_num = _101536</li>
<li>server接收到一个segment，它判断不是100512，依旧把收到的这个segment缓存起来，并回应ack(100512)</li>
<li>以下同6、7,直到client收到3个ack(100512)，进入快速重发阶段：</li>
<li>重设慢启动阀值ssthresh=当前cwnd/2＝70000/2=35000</li>
<li><p>client发送seq_num = 100512</p>
<p>以下，进入快速恢复阶段：<br>11.重设cwnd = ssthresh + 3 segments =35000 + 3<em>512 = 36536，之所以要加3，是因为我们已经接收到3个ack(100512)了，根据前面说的，每接收到一个ack，cwnd加1<br>12.client接收到第四个、第五个ack(100512)，cwnd=36536+2</em>512=37560<br>13.server接收到100512,响应ack_num = _104096<br>14.此时，cwnd&gt;ssthresh，进入拥塞避免阶段。</p>
</li>
</ol>
<p>【思考】：为什么通常clieng每接收到一个ack，会把cwnd增加一个segment呢？<br> 这是基于“管道”模型（pipe model）的“数据包守恒”的原则（conservation of packets principle），即同一时刻在网络中传输的数据包数量是恒定的，只有当“旧”数据包离开网络后，才能发送“新”数据包进入网络。如果发送方收到一个ACK，则认为已经有一个数据包离开了网络，于是将拥塞窗口加1。如果“数据包守恒”原则能够得到严格遵守，那么网络中将很少会发生拥塞；本质上，拥塞控制的目的就是找到违反该原则的地方并进行修正。</p>
<p>五.联想<br>  想想看，能不能把TCP解决拥塞的方法应用到交通拥塞呢？<br>  我们有两个原则：一是拥塞不可避免，单纯增加资源并不能避免拥塞的发生，只能用动态的方法加以解决；二是数据包守恒原则。政府花费很大资金修路，并不能避免堵车，只能从源头控制，例如首先限制车辆进入主路，根据实际情况，再慢慢增加每一个路口的车流量，但是，当达到一个阀值，增加速度要放缓，并不时探测整个主路的拥堵情况，如果情况危急，立刻封闭半个路口，并将车流量降到最低，也就是重新回复到慢启动状态。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-11-05T16:00:00.000Z"><a href="/2016/11/06/network/http/">2016-11-06</a></time>
      
      
  
    <h1 class="title"><a href="/2016/11/06/network/http/">HTTP</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>Reference :</p>
<ol>
<li><a href="http://www.infoq.com/cn/articles/HTTPS-Connection-Jeff-Moser" target="_blank" rel="external">HTTPS连接最初的若干毫秒</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Siguiente</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Buscar">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Categorías</h3>
  <ul class="entry">
  
    <li><a href="/categories/Algorithms/">Algorithms</a><small>2</small></li>
  
    <li><a href="/categories/Design/">Design</a><small>1</small></li>
  
    <li><a href="/categories/Distributed/">Distributed</a><small>10</small></li>
  
    <li><a href="/categories/Language/">Language</a><small>6</small></li>
  
    <li><a href="/categories/Machine-Learning/">Machine Learning</a><small>1</small></li>
  
    <li><a href="/categories/Mathematics/">Mathematics</a><small>1</small></li>
  
    <li><a href="/categories/Network/">Network</a><small>2</small></li>
  
    <li><a href="/categories/OP/">OP</a><small>1</small></li>
  
    <li><a href="/categories/Psychology/">Psychology</a><small>1</small></li>
  
    <li><a href="/categories/Storage/">Storage</a><small>2</small></li>
  
    <li><a href="/categories/live/">live</a><small>4</small></li>
  
    <li><a href="/categories/machine-learning/">machine_learning</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Etiquetas</h3>
  <ul class="entry">
  
    <li><a href="/tags/Algorithms/">Algorithms</a><small>1</small></li>
  
    <li><a href="/tags/Alluxio/">Alluxio</a><small>1</small></li>
  
    <li><a href="/tags/Clojure/">Clojure</a><small>1</small></li>
  
    <li><a href="/tags/Design/">Design</a><small>1</small></li>
  
    <li><a href="/tags/Hadoop/">Hadoop</a><small>5</small></li>
  
    <li><a href="/tags/JVM/">JVM</a><small>1</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>2</small></li>
  
    <li><a href="/tags/Linux/">Linux</a><small>1</small></li>
  
    <li><a href="/tags/Machine-Learning/">Machine Learning</a><small>1</small></li>
  
    <li><a href="/tags/Mathematics/">Mathematics</a><small>1</small></li>
  
    <li><a href="/tags/Mesos/">Mesos</a><small>1</small></li>
  
    <li><a href="/tags/MySQL/">MySQL</a><small>1</small></li>
  
    <li><a href="/tags/Network/">Network</a><small>2</small></li>
  
    <li><a href="/tags/Node/">Node</a><small>1</small></li>
  
    <li><a href="/tags/Politics/">Politics</a><small>1</small></li>
  
    <li><a href="/tags/Psychology/">Psychology</a><small>1</small></li>
  
    <li><a href="/tags/RedBlackTree/">RedBlackTree</a><small>1</small></li>
  
    <li><a href="/tags/RocksDB/">RocksDB</a><small>1</small></li>
  
    <li><a href="/tags/Scala/">Scala</a><small>1</small></li>
  
    <li><a href="/tags/Streaming-Process/">Streaming Process</a><small>1</small></li>
  
    <li><a href="/tags/TensorFlow/">TensorFlow</a><small>1</small></li>
  
    <li><a href="/tags/ZooKeeper/">ZooKeeper</a><small>1</small></li>
  
    <li><a href="/tags/coffee/">coffee</a><small>1</small></li>
  
    <li><a href="/tags/fitness/">fitness</a><small>1</small></li>
  
    <li><a href="/tags/game/">game</a><small>1</small></li>
  
    <li><a href="/tags/spark/">spark</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 Darion Yaphet
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
